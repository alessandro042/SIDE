{% extends "base.html" %}

{% block title %}Estadísticas{% endblock %}

{% block content %}
<style>
    /* Asegúrate de que las fuentes Poppins y Roboto estén importadas en base.html o aquí si es necesario */
    /* @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap'); */
    /* @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&display=swap'); */

    body {
        font-family: 'Poppins', sans-serif; /* Consistente con el diseño */
        background-color: #f0f2f5; /* Fondo gris claro consistente */
    }

    /* Contenedor principal de la página */
    .stats-main-container {
        padding: 30px 20px;
        max-width: 1000px; /* Ancho ajustable para las gráficas */
        margin: 20px auto;
        background-color: #ffffff;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
    }

    .stats-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
    }

    .stats-header h2 {
        font-size: 1.8em; /* Tamaño de fuente del título principal */
        color: #333;
        font-weight: 600;
        margin: 0;
    }

    /* Botón "Volver al Panel" */
    .btn-secondary-custom {
        background-color: #f8f9fa; /* Fondo claro para cancelar/volver */
        color: #6c757d; /* Texto gris */
        padding: 8px 18px; /* Padding para que sean más pequeños */
        border: 1px solid #dee2e6;
        border-radius: 8px;
        font-size: 0.95em; /* Tamaño de fuente más pequeño */
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
        font-weight: 500;
        text-decoration: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); /* Sombra sutil */
    }
    .btn-secondary-custom:hover {
        background-color: #e9ecef;
        color: #495057;
        transform: translateY(-2px);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }

    /* Contenedor de las gráficas */
    #charts-container { /* Cambié el ID a charts-container para ser más específico */
        margin-top: 20px;
    }

    /* Estilo de la tarjeta para cada pregunta/gráfica */
    .chart-card {
        background-color: #fcfcfc; /* Un blanco muy ligero para las tarjetas internas */
        border-radius: 12px; /* Bordes redondeados */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08); /* Sombra más pronunciada */
        border: 1px solid #e0e0e0; /* Borde suave */
        padding: 20px; /* Padding interno */
        margin-bottom: 30px; /* Espacio entre gráficas */
        position: relative;
        z-index: 1;
    }

    .chart-card .card-header {
        background-color: transparent; /* Fondo transparente para el header */
        border-bottom: 1px solid #f0f0f0; /* Borde sutil */
        padding: 0 0 15px 0; /* Padding inferior para separar del cuerpo */
        margin-bottom: 15px; /* Margen para el espacio */
        font-size: 1.1em; /* Tamaño de fuente de la pregunta */
        color: #333;
        font-weight: 600;
    }

    .chart-card .card-body {
        padding: 0; /* Eliminar padding de Bootstrap card-body */
        height: 300px; /* Altura fija para el canvas, puedes ajustar esto */
        display: flex;
        align-items: center;
        justify-content: center;
    }

    canvas {
        max-width: 100%;
        max-height: 100%;
    }
    
    /* Colores personalizados para las barras de la gráfica */
    /* Estas clases son para ser usadas en el JS de Chart.js */
    .chart-color-oracle-blue { background-color: #007ACC; border-color: #007ACC; }
    .chart-color-oracle-red { background-color: #E60000; border-color: #E60000; }
    .chart-color-accent-blue { background-color: #5bc0de; border-color: #5bc0de; } /* Un azul más claro */
    .chart-color-grey { background-color: #6c757d; border-color: #6c757d; }

    /* Estilos para los gradientes en las barras (opcional, si quieres un efecto 3D en Chart.js) */
    /* Chart.js necesita que le pases el gradiente creado en JS, no directamente en CSS */

</style>

<div class="stats-main-container">
    <div class="stats-header">
        <h2 id="questionnaire-title">Cargando estadísticas...</h2>
        <a href="{% url 'dashboard-page' %}" class="btn-secondary-custom">Volver al Panel</a>
    </div>

    <div id="charts-container">
        <p class="text-center text-muted">Cargando gráficas...</p>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const questionnaireId = {{ questionnaire_id }};
    const token = localStorage.getItem('authToken');
    const titleEl = document.getElementById('questionnaire-title');
    const container = document.getElementById('charts-container');
    let charts = {}; 
    let previousData = null;

    if (!token) {
        window.location.href = '/login/';
        return;
    }

    // --- Paleta de colores y funciones de ayuda (sin cambios) ---
    const chartColors = [
        '#007ACC', '#E60000', '#17a2b8', '#28a745', '#ffc107', '#6c757d'
    ];

    function createGradient(ctx, chartArea, colorStart, colorEnd) {
        if (!ctx || !chartArea) return;
        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
        gradient.addColorStop(0, colorEnd);
        gradient.addColorStop(1, colorStart);
        return gradient;
    }
    
    function darkenColor(hex, percent) {
        let f = parseInt(hex.slice(1), 16),
            t = percent < 0 ? 0 : 255,
            p = percent < 0 ? percent * -1 : percent,
            R = f >> 16,
            G = (f >> 8) & 0x00ff,
            B = f & 0x0000ff;
        return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B))
            .toString(16)
            .slice(1);
    }
    // --- Fin de funciones de ayuda ---


    function fetchStats() {
        // La obtención del título no necesita cambiar
        if (titleEl.textContent === 'Cargando estadísticas...') {
            fetch(`/api/questionnaires/${questionnaireId}/`, {
                headers: { 'Authorization': `Token ${token}` }
            })
            .then(response => response.ok ? response.json() : Promise.reject(response))
            .then(data => {
                titleEl.textContent = `Estadísticas de: ${data.title}`;
            })
            .catch(() => {
                localStorage.removeItem('authToken');
                window.location.href = '/login/';
            });
        }

        // Obtención de datos de estadísticas
        fetch(`/api/questionnaires/${questionnaireId}/stats/`, {
            headers: { 'Authorization': `Token ${token}` }
        })
        .then(response => response.ok ? response.json() : Promise.reject(response))
        .then(data => {
            // Si los datos no han cambiado, no hacemos nada.
            if (JSON.stringify(data) === JSON.stringify(previousData)) {
                return; 
            }

            // Si es la primera carga y no hay datos, mostramos un mensaje.
            if (Object.keys(data).length === 0 && previousData === null) {
                container.innerHTML = '<p class="text-center text-muted">Aún no hay respuestas para este cuestionario.</p>';
                previousData = data; // Guardamos el estado "vacío"
                return;
            }

            // --- LÓGICA DE ACTUALIZACIÓN INTELIGENTE ---
            
            const newQuestionIds = new Set(Object.keys(data));

            // 1. PASO DE ELIMINACIÓN:
            // Buscamos gráficas que ya no existen en los datos nuevos y las eliminamos.
            for (const qId in charts) {
                if (!newQuestionIds.has(qId)) {
                    charts[qId].destroy();
                    const cardToRemove = document.getElementById(`chart-card-${qId}`);
                    if (cardToRemove) {
                        cardToRemove.remove();
                    }
                    delete charts[qId];
                }
            }

            // 2. PASO DE ACTUALIZACIÓN Y CREACIÓN:
            // Recorremos los datos nuevos.
            let colorIndex = 0;
            for (const qId in data) {
                const questionData = data[qId];
                
                // Si la gráfica ya existe, solo actualizamos sus datos.
                if (charts[qId]) {
                    const chart = charts[qId];
                    chart.data.labels = questionData.options.map(opt => opt.option_text);
                    chart.data.datasets[0].data = questionData.options.map(opt => opt.votes);
                    chart.update(); // Animación suave de actualización
                } 
                // Si la gráfica no existe, la creamos desde cero.
                else {
                    const card = document.createElement('div');
                    card.className = 'chart-card mb-4';
                    card.id = `chart-card-${qId}`; // Asignamos un ID único a la tarjeta

                    const cardHeader = document.createElement('div');
                    cardHeader.className = 'card-header';
                    cardHeader.textContent = questionData.question_text;
                    card.appendChild(cardHeader);

                    const canvasContainer = document.createElement('div');
                    canvasContainer.className = 'card-body';
                    const canvas = document.createElement('canvas');
                    canvasContainer.appendChild(canvas);
                    card.appendChild(canvasContainer);
                    
                    // La añadimos al final del contenedor
                    container.appendChild(card);

                    const barBackgroundColors = questionData.options.map((opt, index) => {
                        const currentColor = chartColors[(colorIndex + index) % chartColors.length];
                        const darkerColor = darkenColor(currentColor, 20);
                        return (context) => {
                            const { chart } = context;
                            if (!chart.chartArea) return null;
                            return createGradient(chart.ctx, chart.chartArea, currentColor, darkerColor);
                        };
                    });
                    
                    colorIndex = (colorIndex + questionData.options.length) % chartColors.length;

                    charts[qId] = new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: questionData.options.map(opt => opt.option_text),
                            datasets: [{
                                label: 'Votos',
                                data: questionData.options.map(opt => opt.votes),
                                backgroundColor: barBackgroundColors,
                                borderColor: 'transparent',
                                borderWidth: 0,
                                borderRadius: 6,
                                barThickness: 'flex',
                                maxBarThickness: 30
                            }]
                        },
                        options: { 
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            animation: { duration: 1000, easing: 'easeOutQuart' },
                            scales: { 
                                x: { beginAtZero: true, ticks: { font: { family: 'Roboto', size: 12 }, color: '#777' }, grid: { display: false, drawBorder: false }},
                                y: { ticks: { font: { family: 'Poppins', size: 13, weight: 'bold' }, color: '#555' }, grid: { display: false, drawBorder: false }}
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    enabled: true,
                                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                    titleFont: { family: 'Poppins', size: 14, weight: 'bold' },
                                    bodyFont: { family: 'Roboto', size: 13 },
                                    padding: 10,
                                    displayColors: false,
                                    callbacks: {
                                        label: (context) => `Votos: ${new Intl.NumberFormat('es-MX').format(context.raw)}`
                                    }
                                }
                            }
                        }
                    });
                }
            }

            // Finalmente, actualizamos los datos de referencia.
            previousData = data;
        })
        .catch(error => {
            console.error("Error al cargar las estadísticas:", error);
            // No limpiamos el contenedor para no perder la vista en un error de red temporal
        });
    }

    // --- Llamadas iniciales (sin cambios) ---
    fetchStats();
    setInterval(fetchStats, 5000);
});
</script>
{% endblock %}